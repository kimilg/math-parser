// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteEquation = `-- name: DeleteEquation :exec
DELETE FROM equation
WHERE id=$1
`

func (q *Queries) DeleteEquation(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteEquation, id)
	return err
}

const deleteVariable = `-- name: DeleteVariable :exec
DELETE FROM variable
WHERE id=$1
`

func (q *Queries) DeleteVariable(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteVariable, id)
	return err
}

const getEquation = `-- name: GetEquation :one
SELECT e.id, e.value, e.category, e.cause, e.effect, e.created_at, e.updated_at, e.deleted_at,
       json_agg(DISTINCT jsonb_build_object('id', v.id, 'name', v.name, 'vcategory', v.vcategory, 'arguments', v.arguments))
       FILTER (WHERE v.id IS NOT NULL) AS variables
FROM equation e
    LEFT OUTER JOIN equation_variable ev 
        ON e.id = ev.equation_id 
    LEFT OUTER JOIN variable v 
        ON ev.variable_id = v.id
WHERE e.id = $1 
GROUP BY e.id
LIMIT 1
`

type GetEquationRow struct {
	ID        int64
	Value     string
	Category  string
	Cause     pgtype.Text
	Effect    pgtype.Text
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
	DeletedAt pgtype.Timestamp
	Variables []byte
}

func (q *Queries) GetEquation(ctx context.Context, id int64) (GetEquationRow, error) {
	row := q.db.QueryRow(ctx, getEquation, id)
	var i GetEquationRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.Category,
		&i.Cause,
		&i.Effect,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Variables,
	)
	return i, err
}

const getEquationFromValue = `-- name: GetEquationFromValue :one
SELECT e.id, e.value, e.category, e.cause, e.effect, e.created_at, e.updated_at, e.deleted_at,
       json_agg(DISTINCT jsonb_build_object('id', v.id, 'name', v.name, 'vcategory', v.vcategory, 'arguments', v.arguments))
       FILTER (WHERE v.id IS NOT NULL) AS variables
FROM equation e
    LEFT OUTER JOIN equation_variable ev 
        ON e.id = ev.equation_id 
    LEFT OUTER JOIN variable v 
        ON ev.variable_id = v.id
WHERE e.value = $1
GROUP BY e.id
LIMIT 1
`

type GetEquationFromValueRow struct {
	ID        int64
	Value     string
	Category  string
	Cause     pgtype.Text
	Effect    pgtype.Text
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
	DeletedAt pgtype.Timestamp
	Variables []byte
}

func (q *Queries) GetEquationFromValue(ctx context.Context, value string) (GetEquationFromValueRow, error) {
	row := q.db.QueryRow(ctx, getEquationFromValue, value)
	var i GetEquationFromValueRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.Category,
		&i.Cause,
		&i.Effect,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Variables,
	)
	return i, err
}

const insertEquation = `-- name: InsertEquation :one
INSERT INTO equation (value, category, cause, effect, created_at, updated_at) 
VALUES ($1, $2, $3, $4, current_timestamp, current_timestamp)
RETURNING id, value, category, cause, effect, created_at, updated_at, deleted_at
`

type InsertEquationParams struct {
	Value    string
	Category string
	Cause    pgtype.Text
	Effect   pgtype.Text
}

func (q *Queries) InsertEquation(ctx context.Context, arg InsertEquationParams) (Equation, error) {
	row := q.db.QueryRow(ctx, insertEquation,
		arg.Value,
		arg.Category,
		arg.Cause,
		arg.Effect,
	)
	var i Equation
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.Category,
		&i.Cause,
		&i.Effect,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const insertVariable = `-- name: InsertVariable :one
WITH inserted_id AS (
    INSERT INTO variable (name, vcategory, arguments, created_at, updated_at)
        VALUES ($1, $2, $3, current_timestamp, current_timestamp)
        ON CONFLICT (name, vcategory) DO NOTHING
        RETURNING id
), 
inserted_id_union AS (
    SELECT id 
    FROM inserted_id
    UNION
    SELECT v.id
    FROM variable v
    WHERE v.name = $1
      AND v.vcategory = $2
),
eq_var AS (
    INSERT INTO equation_variable (equation_id, variable_id)
        VALUES ($4, (SELECT id FROM inserted_id_union))
        ON CONFLICT (equation_id, variable_id) DO NOTHING
        RETURNING equation_id, variable_id
)
SELECT equation_id, variable_id FROM eq_var
UNION 
SELECT equation_id, variable_id FROM equation_variable ev
    WHERE ev.equation_id = $4 AND
          ev.variable_id = (SELECT id FROM inserted_id_union)
`

type InsertVariableParams struct {
	Name       string
	Vcategory  string
	Arguments  []byte
	EquationID int64
}

type InsertVariableRow struct {
	EquationID int64
	VariableID int64
}

func (q *Queries) InsertVariable(ctx context.Context, arg InsertVariableParams) (InsertVariableRow, error) {
	row := q.db.QueryRow(ctx, insertVariable,
		arg.Name,
		arg.Vcategory,
		arg.Arguments,
		arg.EquationID,
	)
	var i InsertVariableRow
	err := row.Scan(&i.EquationID, &i.VariableID)
	return i, err
}

const listEquations = `-- name: ListEquations :many
SELECT e.id, e.value, e.category, e.cause, e.effect, e.created_at, e.updated_at, e.deleted_at, 
       json_agg(DISTINCT jsonb_build_object('id', v.id, 'name', v.name, 'vcategory', v.vcategory, 'arguments', v.arguments)) 
       FILTER (WHERE v.id IS NOT NULL) AS variables
FROM equation e 
    LEFT OUTER JOIN equation_variable ev 
        ON e.id = ev.equation_id 
    LEFT OUTER JOIN variable v 
        ON ev.variable_id = v.id
GROUP BY e.id
ORDER BY e.id
`

type ListEquationsRow struct {
	ID        int64
	Value     string
	Category  string
	Cause     pgtype.Text
	Effect    pgtype.Text
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
	DeletedAt pgtype.Timestamp
	Variables []byte
}

func (q *Queries) ListEquations(ctx context.Context) ([]ListEquationsRow, error) {
	rows, err := q.db.Query(ctx, listEquations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEquationsRow
	for rows.Next() {
		var i ListEquationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.Category,
			&i.Cause,
			&i.Effect,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Variables,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEquation = `-- name: UpdateEquation :one
UPDATE equation
SET value=$2, category=$3, cause=$4, effect=$5, updated_at=current_timestamp
WHERE id=$1
RETURNING id, value, category, cause, effect, created_at, updated_at, deleted_at
`

type UpdateEquationParams struct {
	ID       int64
	Value    string
	Category string
	Cause    pgtype.Text
	Effect   pgtype.Text
}

func (q *Queries) UpdateEquation(ctx context.Context, arg UpdateEquationParams) (Equation, error) {
	row := q.db.QueryRow(ctx, updateEquation,
		arg.ID,
		arg.Value,
		arg.Category,
		arg.Cause,
		arg.Effect,
	)
	var i Equation
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.Category,
		&i.Cause,
		&i.Effect,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
